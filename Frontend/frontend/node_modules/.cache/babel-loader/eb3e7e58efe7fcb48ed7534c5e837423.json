{"ast":null,"code":"import * as React from 'react';\nimport setRef from './setRef';\nexport default function useForkRef(refA, refB) {\n  /**\n   * This will create a new function if the ref props change and are defined.\n   * This means react will call the old forkRef with `null` and the new forkRef\n   * with the ref. Cleanup naturally emerges from this behavior.\n   */\n  return React.useMemo(() => {\n    if (refA == null && refB == null) {\n      return null;\n    }\n    return refValue => {\n      setRef(refA, refValue);\n      setRef(refB, refValue);\n    };\n  }, [refA, refB]);\n}","map":{"version":3,"names":["React","setRef","useForkRef","refA","refB","useMemo","refValue"],"sources":["D:/open_source/hacktobarfest/Oju-s-Blogs/Frontend/frontend/node_modules/@mui/utils/esm/useForkRef.js"],"sourcesContent":["import * as React from 'react';\nimport setRef from './setRef';\nexport default function useForkRef(refA, refB) {\n  /**\n   * This will create a new function if the ref props change and are defined.\n   * This means react will call the old forkRef with `null` and the new forkRef\n   * with the ref. Cleanup naturally emerges from this behavior.\n   */\n  return React.useMemo(() => {\n    if (refA == null && refB == null) {\n      return null;\n    }\n\n    return refValue => {\n      setRef(refA, refValue);\n      setRef(refB, refValue);\n    };\n  }, [refA, refB]);\n}"],"mappings":"AAAA,OAAO,KAAKA,KAAK,MAAM,OAAO;AAC9B,OAAOC,MAAM,MAAM,UAAU;AAC7B,eAAe,SAASC,UAAUA,CAACC,IAAI,EAAEC,IAAI,EAAE;EAC7C;AACF;AACA;AACA;AACA;EACE,OAAOJ,KAAK,CAACK,OAAO,CAAC,MAAM;IACzB,IAAIF,IAAI,IAAI,IAAI,IAAIC,IAAI,IAAI,IAAI,EAAE;MAChC,OAAO,IAAI;IACb;IAEA,OAAOE,QAAQ,IAAI;MACjBL,MAAM,CAACE,IAAI,EAAEG,QAAQ,CAAC;MACtBL,MAAM,CAACG,IAAI,EAAEE,QAAQ,CAAC;IACxB,CAAC;EACH,CAAC,EAAE,CAACH,IAAI,EAAEC,IAAI,CAAC,CAAC;AAClB"},"metadata":{},"sourceType":"module"}